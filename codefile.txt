// main.cpp


#include "rrtstar.h"
#include <iostream>
#include <string>

int main() {
    // Define 3D start and goal positions
    double start_x = 10, start_y = 10, start_z = 10;
    double goal_x = 75, goal_y = 81, goal_z = 67;

    // Define 3D map bounds
    double map_width = 100, map_height = 100, map_depth = 100;

    // Define RRT* parameters
    double step_size = 7.0;     // Step size for extending tree
    double neighbor_radius = 30.0;  // Radius for rewiring
    double safety_margin = 3.0;     // Safety margin around obstacles
    int max_iter = 5000;        // Maximum iterations

    try {
        // Create RRT* instance with 3D parameters
        RRTStar rrtstar(
            start_x, start_y, start_z,      // Start position
            goal_x, goal_y, goal_z,         // Goal position
            map_width, map_height, map_depth,// Map dimensions
            step_size, neighbor_radius,     // Planning parameters
            safety_margin, max_iter         // Additional parameters
        );

        // Find the path
        std::cout << "Finding path in 3D space..." << std::endl;
        std::vector<Node*> path = rrtstar.findPath();

        // Check if a path was found
        if (path.empty()) {
            std::cout << "No path found!" << std::endl;
            return 1;
        }

        // Path found successfully
        std::cout << "Path found with " << path.size() << " nodes!" << std::endl;

        // Print path coordinates
        std::cout << "\nPath coordinates (x, y, z):" << std::endl;
        for (auto* node : path) {
            std::cout << "(" << node->x << ", " << node->y << ", " << node->z << ")" << std::endl;
        }

        // Calculate path length
        double path_length = 0.0;
        for (size_t i = 1; i < path.size(); ++i) {
            double dx = path[i]->x - path[i - 1]->x;
            double dy = path[i]->y - path[i - 1]->y;
            double dz = path[i]->z - path[i - 1]->z;
            path_length += std::sqrt(dx * dx + dy * dy + dz * dz);
        }
        std::cout << "\nTotal path length: " << path_length << " units" << std::endl;

        // Export data to a file
        std::string export_filename = "/home/thornch/Documents/Cpp/PathPlanning/rrtstar_test1/output_data.txt"; // Specify the output file name
        exportData(path, RRTStar::getObstacles(), export_filename); // Call the exportData function
        std::cout << "Data exported to " << export_filename << std::endl;

        // Visualize the path in 3D
        std::cout << "\nVisualizing 3D path..." << std::endl;
        rrtstar.visualizePath(path);

        return 0;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
}

// rrtstar.cpp
#include "rrtstar.h"
#include "spline.h"
#include <iostream>
#include <algorithm>
#include <execution>
#include <matplotlibcpp.h>
#include <memory>
#include <fstream>
#include <vector>

namespace plt = matplotlibcpp;

// Define 3D obstacles with AABB (Axis-Aligned Bounding Box)
std::vector<Obstacle> RRTStar::obstacles = {
    Obstacle({45, 45, 45}, {55, 55, 55}),  // First cubic obstacle
    Obstacle({65, 65, 65}, {75, 75, 75})   // Second cubic obstacle
};

RRTStar::RRTStar(double start_x, double start_y, double start_z,
                 double goal_x, double goal_y, double goal_z,
                 double map_width, double map_height, double map_depth,
                 double step_size, double neighbor_radius,
                 double safety_margin, int max_iter)
    : map_width(map_width), map_height(map_height), map_depth(map_depth),
      step_size(step_size), neighbor_radius(neighbor_radius),
      safety_margin(safety_margin), max_iter(max_iter),
      gen(std::random_device{}()),
      dis_x(0, map_width), dis_y(0, map_height), dis_z(0, map_depth),
      node_adapter(nodes)
{
    if (!isStateValid(start_x, start_y, start_z) || 
        !isStateValid(goal_x, goal_y, goal_z)) {
        throw std::invalid_argument("Start or goal position is invalid!");
    }

    start_node = std::make_unique<Node>(start_x, start_y, start_z);
    goal_node = std::make_unique<Node>(goal_x, goal_y, goal_z);
    nodes.push_back(start_node.get());

    kdtree = std::make_unique<nanoflann::KDTreeSingleIndexAdaptor<
        nanoflann::L2_Simple_Adaptor<double, NodeAdapter>,
        NodeAdapter, 3>>(3, node_adapter, nanoflann::KDTreeSingleIndexAdaptorParams());
    kdtree->buildIndex();
}

RRTStar::~RRTStar() = default;

bool RRTStar::lineAABBIntersection(const std::array<double, 3>& start,
                                  const std::array<double, 3>& end,
                                  const std::array<double, 3>& box_min,
                                  const std::array<double, 3>& box_max) {
    std::array<double, 3> dir = {
        (end[0] - start[0]) * 0.5,
        (end[1] - start[1]) * 0.5,
        (end[2] - start[2]) * 0.5
    };
    
    std::array<double, 3> mid = {
        (start[0] + end[0]) * 0.5,
        (start[1] + end[1]) * 0.5,
        (start[2] + end[2]) * 0.5
    };
    
    std::array<double, 3> extent = {
        std::abs(dir[0]), std::abs(dir[1]), std::abs(dir[2])
    };
    
    // Normalize direction vector
    double length = std::sqrt(dir[0]*dir[0] + dir[1]*dir[1] + dir[2]*dir[2]);
    if (length > 1e-9) {
        for (int i = 0; i < 3; i++) dir[i] /= length;
    }

    std::array<double, 3> box_center = {
        (box_min[0] + box_max[0]) * 0.5,
        (box_min[1] + box_max[1]) * 0.5,
        (box_min[2] + box_max[2]) * 0.5
    };
    
    std::array<double, 3> box_half = {
        (box_max[0] - box_min[0]) * 0.5,
        (box_max[1] - box_min[1]) * 0.5,
        (box_max[2] - box_min[2]) * 0.5
    };

    std::array<double, 3> t = {
        mid[0] - box_center[0],
        mid[1] - box_center[1],
        mid[2] - box_center[2]
    };

    // Test axes
    for (int i = 0; i < 3; i++) {
        if (std::abs(t[i]) > box_half[i] + extent[i]) return false;
    }

    // Test cross products
    for (int i = 0; i < 3; i++) {
        int a = (i+1)%3;
        int b = (i+2)%3;
        double radius = box_half[a] * std::abs(dir[b]) + box_half[b] * std::abs(dir[a]);
        double distance = std::abs(t[a] * dir[b] - t[b] * dir[a]);
        if (distance > radius) return false;
    }

    return true;
}

std::vector<Node*> RRTStar::findPath() {
    for (int i = 0; i < max_iter; ++i) {
        auto random_node = getRandomNode();
        // if (i % 10 == 0) {  // Bias towards goal
        //     random_node = std::make_unique<Node>(goal_node->x, goal_node->y, goal_node->z);  // Add z coordinate
        // }
        std::uniform_real_distribution<> dis(0.0, 1.0);
        if(dis(gen) < 0.1)
        {
            random_node = std::make_unique<Node>(goal_node->x, goal_node->y, goal_node->z);
        }

        Node* nearest_node = nearest(random_node.get());
        auto new_node = steer(nearest_node, random_node.get());

        if (isCollisionFree(nearest_node, new_node.get())) {
            std::vector<Node*> neighbors = radiusSearch(new_node.get(), neighbor_radius);
            Node* min_cost_node = nearest_node;
            double min_cost = nearest_node->cost + distance(nearest_node, new_node.get());

            for (auto& neighbor : neighbors) {
                if (isCollisionFree(neighbor, new_node.get())) {
                    double tentative_cost = neighbor->cost + distance(neighbor, new_node.get());
                    if (tentative_cost < min_cost) {
                        min_cost = tentative_cost;
                        min_cost_node = neighbor;
                    }
                }
            }

            new_node->parent = min_cost_node;
            new_node->cost = min_cost;

            nodes.push_back(new_node.get());
            node_storage.push_back(std::move(new_node));
            // kdtree->buildIndex();
            if (nodes.size() % 10 == 0) { // Rebuild every 10 nodes
                kdtree->buildIndex();
            }
            
            rewire(neighbors, nodes.back());

            if (distance(nodes.back(), goal_node.get()) <= step_size && 
                isCollisionFree(nodes.back(), goal_node.get())) {
                goal_node->parent = nodes.back();
                goal_node->cost = nodes.back()->cost + distance(nodes.back(), goal_node.get());
                std::cout << "Goal reached at iteration " << i << "!" << std::endl;
                break;
            }
        }
    }

    std::vector<Node*> path;
    if (goal_node->parent != nullptr) {
        getFinalPath(goal_node.get(), path);
    }

    if (!path.empty()) {
        optimizePath(path);      // Shorten the path
        smoothPath(path);        // Apply spline smoothing
    }
    return path;
}

std::unique_ptr<Node> RRTStar::getRandomNode() {
    double x, y, z;
    std::uniform_real_distribution<> dis(0.0, 1.0);

    if (dis(gen) < 0.1) { // Fixed goal biasing probability
        return std::make_unique<Node>(goal_node->x, goal_node->y, goal_node->z);
    }

    do {
        x = dis_x(gen);
        y = dis_y(gen);
        z = dis_z(gen);
    } while (!isStateValid(x, y, z));

    return std::make_unique<Node>(x, y, z);
}

std::unique_ptr<Node> RRTStar::steer(Node* nearest_node, Node* random_node) {
    double dx = random_node->x - nearest_node->x;
    double dy = random_node->y - nearest_node->y;
    double dz = random_node->z - nearest_node->z;
    double distance = std::sqrt(dx * dx + dy * dy + dz * dz);

    double dynamic_step_size = step_size;
    if (distance < 2 * neighbor_radius) { // Near obstacles or goal
        dynamic_step_size /= 2.0;
    }

    if (distance <= dynamic_step_size) {
        return std::make_unique<Node>(random_node->x, random_node->y, random_node->z);
    }

    double ratio = dynamic_step_size / distance;
    double new_x = nearest_node->x + dx * ratio;
    double new_y = nearest_node->y + dy * ratio;
    double new_z = nearest_node->z + dz * ratio;

    return std::make_unique<Node>(new_x, new_y, new_z);
}

bool RRTStar::isCollisionFree(Node* node1, Node* node2) {
    auto p1 = node1->position();
    auto p2 = node2->position();
    
    // Check against all obstacles with safety margin
    for (const auto& obstacle : obstacles) {
        std::array<double, 3> expanded_min = {
            obstacle.min_point[0] - safety_margin,
            obstacle.min_point[1] - safety_margin,
            obstacle.min_point[2] - safety_margin
        };
        std::array<double, 3> expanded_max = {
            obstacle.max_point[0] + safety_margin,
            obstacle.max_point[1] + safety_margin,
            obstacle.max_point[2] + safety_margin
        };

        if (lineAABBIntersection(p1, p2, expanded_min, expanded_max)) {
            return false;
        }
    }
    return true;
}

void RRTStar::rewire(const std::vector<Node*>& neighbors, Node* new_node) {
    std::for_each(std::execution::par, neighbors.begin(), neighbors.end(), [&](Node* neighbor) {
        if (isCollisionFree(neighbor, new_node)) {
            double tentative_cost = new_node->cost + distance(new_node, neighbor);
            if (tentative_cost < neighbor->cost) {
                neighbor->parent = new_node;
                neighbor->cost = tentative_cost;
            }
        }
    });
}

double RRTStar::distance(Node* node1, Node* node2) {
    return std::sqrt((node1->x - node2->x) * (node1->x - node2->x) +
                    (node1->y - node2->y) * (node1->y - node2->y) +
                    (node1->z - node2->z) * (node1->z - node2->z));  // Add z component
}

Node* RRTStar::nearest(Node* target) {
    double query_pt[3] = {target->x, target->y, target->z};
    unsigned int index; // Change size_t to unsigned int
    double min_dist_sq;
    kdtree->knnSearch(query_pt, 1, &index, &min_dist_sq);
    return nodes[index];
}

std::vector<Node*> RRTStar::radiusSearch(Node* target, double radius) {
    double query_pt[3] = {target->x, target->y, target->z};
    std::vector<nanoflann::ResultItem<unsigned int, double>> matches; // Correct type
    kdtree->radiusSearch(query_pt, radius * radius, matches); // Perform radius search

    std::vector<Node*> result;
    for (const auto& match : matches) {
        result.push_back(nodes[match.first]); // Use match.first for the index
    }
    return result;
}

void RRTStar::getFinalPath(Node* goal_node, std::vector<Node*>& path) {
    Node* current = goal_node;
    while (current != nullptr) {
        path.push_back(current);
        current = current->parent;
    }
    std::reverse(path.begin(), path.end());
}

void RRTStar::optimizePath(std::vector<Node*>& path) {
    if (path.size() < 3) return;

    bool improved;
    do {
        improved = false;
        // Forward pass
        size_t i = 0;
        while (i < path.size() - 2) {
            if (isCollisionFree(path[i], path[i + 2])) {
                path.erase(path.begin() + i + 1);
                improved = true;
            } else {
                i++;
            }
        }

        // Backward pass to catch missed opportunities
        i = path.size() - 1;
        while (i >= 2) {
            if (isCollisionFree(path[i - 2], path[i])) {
                path.erase(path.begin() + i - 1);
                improved = true;
            }
            i--;
        }
    } while (improved); // Repeat until no more improvements
}

bool RRTStar::isStateValid(double x, double y, double z) {
    return x >= 0 && x <= map_width &&
           y >= 0 && y <= map_height &&
           z >= 0 && z <= map_depth;
}

bool RRTStar::isObstacle(double x, double y, double z) {
    std::array<double, 3> point = {x, y, z};
    
    for (const auto& obstacle : obstacles) {
        bool inside = true;
        for (int i = 0; i < 3; ++i) {
            if (point[i] < obstacle.min_point[i] - safety_margin || 
                point[i] > obstacle.max_point[i] + safety_margin) {
                inside = false;
                break;
            }
        }
        if (inside) return true;
    }
    return false;
}

void RRTStar::visualizePath(const std::vector<Node*>& path) {
    // Set backend explicitly for headless environments
    plt::backend("Agg");

    // Create a new figure
    plt::figure_size(1200, 800);

    // Plot tree nodes and edges
    std::vector<double> x_coords, y_coords, z_coords;
    for (const auto& node : nodes) {
        x_coords.push_back(node->x);
        y_coords.push_back(node->y);
        z_coords.push_back(node->z);
    }

    // Plot tree edges
    for (const auto& node : nodes) {
        if (node->parent != nullptr) {
            std::vector<double> edge_x = {node->x, node->parent->x};
            std::vector<double> edge_y = {node->y, node->parent->y};
            std::vector<double> edge_z = {node->z, node->parent->z};
            plt::plot3(edge_x, edge_y, edge_z, {{"color", "lightblue"}, {"linestyle", "-"}, {"linewidth", "0.5"}});
        }
    }

    // Plot all nodes
    plt::plot3(x_coords, y_coords, z_coords, {{"color", "blue"}, {"marker", "."}, 
        {"linestyle", "none"}, {"markersize", "5"}, {"label", "Tree Nodes"}});

    // Plot original path
    if (!path.empty()) {
        std::vector<double> path_x, path_y, path_z;
        for (const auto& node : path) {
            path_x.push_back(node->x);
            path_y.push_back(node->y);
            path_z.push_back(node->z);
        }
        plt::plot3(path_x, path_y, path_z, {{"color", "orange"}, {"linestyle", "--"}, 
            {"linewidth", "2.0"}, {"label", "Original Path"}});
    }

    // Plot start and goal
    std::vector<double> start_xyz = {start_node->x, start_node->y, start_node->z};
    plt::plot3(std::vector<double>{start_xyz[0]}, 
               std::vector<double>{start_xyz[1]}, 
               std::vector<double>{start_xyz[2]}, 
               {{"color", "green"}, {"marker", "*"}, {"markersize", "15"}, {"label", "Start"}});

    std::vector<double> goal_xyz = {goal_node->x, goal_node->y, goal_node->z};
    plt::plot3(std::vector<double>{goal_xyz[0]}, 
               std::vector<double>{goal_xyz[1]}, 
               std::vector<double>{goal_xyz[2]}, 
               {{"color", "red"}, {"marker", "*"}, {"markersize", "15"}, {"label", "Goal"}});

    // Plot obstacles
    for (const auto& obstacle : obstacles) {
        // Plot each face of the box
        std::array<double, 8> x_corners = {
            obstacle.min_point[0], obstacle.max_point[0],
            obstacle.max_point[0], obstacle.min_point[0],
            obstacle.min_point[0], obstacle.max_point[0],
            obstacle.max_point[0], obstacle.min_point[0]
        };
        std::array<double, 8> y_corners = {
            obstacle.min_point[1], obstacle.min_point[1],
            obstacle.max_point[1], obstacle.max_point[1],
            obstacle.min_point[1], obstacle.min_point[1],
            obstacle.max_point[1], obstacle.max_point[1]
        };
        std::array<double, 8> z_corners = {
            obstacle.min_point[2], obstacle.min_point[2],
            obstacle.min_point[2], obstacle.min_point[2],
            obstacle.max_point[2], obstacle.max_point[2],
            obstacle.max_point[2], obstacle.max_point[2]
        };
        // Plot box edges
        for (int i = 0; i < 4; ++i) {
            int j = (i + 1) % 4;
            std::vector<double> edge_x = {x_corners[i], x_corners[j]};
            std::vector<double> edge_y = {y_corners[i], y_corners[j]};
            std::vector<double> edge_z = {z_corners[i], z_corners[j]};
            plt::plot3(edge_x, edge_y, edge_z, {{"color", "black"}, {"linestyle", "-"}, {"alpha", "0.5"}});
            // Vertical edges
            std::vector<double> v_edge_x = {x_corners[i], x_corners[i+4]};
            std::vector<double> v_edge_y = {y_corners[i], y_corners[i+4]};
            std::vector<double> v_edge_z = {z_corners[i], z_corners[i+4]};
            plt::plot3(v_edge_x, v_edge_y, v_edge_z, {{"color", "black"}, {"linestyle", "-"}, {"alpha", "0.5"}});
        }
    }

    // Add labels, title, grid, and legend
    plt::xlabel("X");
    plt::ylabel("Y");
    plt::set_zlabel("Z");
    plt::title("RRT* Path Planning in 3D");
    plt::grid(true);
    plt::legend();

    // Save the plot to a file
    plt::save("/home/thornch/Documents/Cpp/PathPlanning/rrtstar_test1/path_plot.png");
    std::cout << "Plot saved to path_plot.png" << std::endl;

    // Close the figure to free resources
    // plt.close();
    plt::clf();
}

void RRTStar::plotCuboid(const std::array<double, 3>& min_point,
                        const std::array<double, 3>& max_point,
                        const std::map<std::string, std::string>& style) {
    // Plot each face of the cuboid
    double x_min = min_point[0], y_min = min_point[1], z_min = min_point[2];
    double x_max = max_point[0], y_max = max_point[1], z_max = max_point[2];

    // Bottom face
    std::vector<double> x = {x_min, x_max, x_max, x_min, x_min};
    std::vector<double> y = {y_min, y_min, y_max, y_max, y_min};
    std::vector<double> z(5, z_min);
    plt::plot3(x, y, z, style);

    // Top face
    std::vector<double> z_top(5, z_max);
    plt::plot3(x, y, z_top, style);

    // Vertical edges
    for (int i = 0; i < 4; ++i) {
        std::vector<double> x_edge = {x[i]};
        std::vector<double> y_edge = {y[i]};
        std::vector<double> z_edge = {z_min, z_max};
        plt::plot3(x_edge, y_edge, z_edge, style);
    }
}

void exportData(const std::vector<Node*>& path, const std::vector<Obstacle>& obstacles, const std::string& filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open file for exporting data." << std::endl;
        return;
    }

    // Write original path
    file << "original_path\n";
    for (const auto& node : path) {
        file << node->x << "," << node->y << "," << node->z << "\n";
    }

    // Write smoothed path (if applicable)
    file << "smoothed_path\n";
    for (const auto& node : path) {
        file << node->x << "," << node->y << "," << node->z << "\n";
    }

    // Write obstacles
    file << "obstacles\n";
    for (const auto& obstacle : obstacles) {
        file << obstacle.min_point[0] << "," << obstacle.min_point[1] << "," << obstacle.min_point[2] << ","
             << obstacle.max_point[0] << "," << obstacle.max_point[1] << "," << obstacle.max_point[2] << "\n";
    }

    file.close();
}

void RRTStar::smoothPath(std::vector<Node*>& path) {
    if (path.size() < 3) return;

    // Convert path to 3D points
    std::vector<std::array<double, 3>> points;
    for (auto* node : path) {
        points.push_back({node->x, node->y, node->z});
    }

    // Interpolate using splines
    Spline spline;
    auto smoothed_points = spline.interpolate(points, 10); // 10 points per segment

    // Rebuild the path with smoothed points (and check collisions)
    std::vector<Node*> new_path;
    new_path.push_back(path[0]); // Keep start

    for (size_t i = 1; i < smoothed_points.size() - 1; ++i) {
        Node* prev = new_path.back();
        Node* current = new Node(
            smoothed_points[i][0], 
            smoothed_points[i][1], 
            smoothed_points[i][2]
        );

        if (isCollisionFree(prev, current)) {
            new_path.push_back(current);
        } else {
            // Fallback: Keep the original node if collision
            new_path.push_back(path[i]);
        }
    }

    new_path.push_back(path.back()); // Keep goal
    path = new_path;
}


// rrtstar.h
#ifndef RRTSTAR_H
#define RRTSTAR_H

#include <vector>
#include <memory>
#include <random>
#include <cmath>
#include <limits>
#include <map>
#include <string>
#include "nanoflann.hpp"

struct Node {
    double x, y, z;
    Node* parent = nullptr;
    double cost = 0.0;

    Node(double x, double y, double z) : x(x), y(y), z(z) {}
    
    std::array<double, 3> position() const {
        return {x, y, z};
    }
};

struct Obstacle {
    std::array<double, 3> min_point;
    std::array<double, 3> max_point;
    
    Obstacle(const std::array<double, 3>& min, const std::array<double, 3>& max) 
        : min_point(min), max_point(max) {}
};

class RRTStar {
private:
    // Adapter for nanoflann in 3D
    struct NodeAdapter {
        std::vector<Node*>& nodes;

        NodeAdapter(std::vector<Node*>& nodes) : nodes(nodes) {}

        inline size_t kdtree_get_point_count() const { return nodes.size(); }

        inline double kdtree_get_pt(const size_t idx, const size_t dim) const {
            switch(dim) {
                case 0: return nodes[idx]->x;
                case 1: return nodes[idx]->y;
                case 2: return nodes[idx]->z;
                default: return 0.0;
            }
        }

        template <class BBOX>
        bool kdtree_get_bbox(BBOX&) const { return false; }
    };

    // Map parameters
    double map_width, map_height, map_depth;
    double step_size, neighbor_radius, safety_margin;
    int max_iter;

    // Random number generation
    std::mt19937 gen;
    std::uniform_real_distribution<> dis_x, dis_y, dis_z;

    // Nodes and storage
    std::vector<Node*> nodes;
    std::vector<std::unique_ptr<Node>> node_storage;
    NodeAdapter node_adapter;
    
    // KD-tree for efficient nearest neighbor search
    std::unique_ptr<nanoflann::KDTreeSingleIndexAdaptor<
        nanoflann::L2_Simple_Adaptor<double, NodeAdapter>,
        NodeAdapter, 3>> kdtree;

    // Start and goal nodes
    std::unique_ptr<Node> start_node;
    std::unique_ptr<Node> goal_node;

    // Static obstacle list
    static std::vector<Obstacle> obstacles;

    // Helper functions
    std::unique_ptr<Node> getRandomNode();
    std::unique_ptr<Node> steer(Node* nearest_node, Node* random_node);
    bool isCollisionFree(Node* node1, Node* node2);
    void rewire(const std::vector<Node*>& neighbors, Node* new_node);
    bool isObstacle(double x, double y, double z);
    bool lineAABBIntersection(const std::array<double, 3>& start,
                             const std::array<double, 3>& end,
                             const std::array<double, 3>& box_min,
                             const std::array<double, 3>& box_max);
        

public:
    RRTStar(double start_x, double start_y, double start_z,
            double goal_x, double goal_y, double goal_z,
            double map_width, double map_height, double map_depth,
            double step_size, double neighbor_radius,
            double safety_margin, int max_iter);
    
    ~RRTStar();

    std::vector<Node*> findPath();
    void getFinalPath(Node* goal_node, std::vector<Node*>& path);
    void optimizePath(std::vector<Node*>& path);
    bool isStateValid(double x, double y, double z);
    void visualizePath(const std::vector<Node*>& path);

    Node* nearest(Node* target);
    std::vector<Node*> radiusSearch(Node* target, double radius);
    double distance(Node* node1, Node* node2);

    // Getter for obstacles
    static const std::vector<Obstacle>& getObstacles() {
        return obstacles;
    }

    void smoothPath(std::vector<Node*>& path);
    
private:
    std::vector<Node*> smoothPath(const std::vector<Node*>& path);
    void plotCuboid(const std::array<double, 3>& min_point,
                    const std::array<double, 3>& max_point,
                    const std::map<std::string, std::string>& style);
};

// Declare the exportData function
void exportData(const std::vector<Node*>& path, const std::vector<Obstacle>& obstacles, const std::string& filename);

#endif // RRTSTAR_H

// spline.h
#ifndef SPLINE_H
#define SPLINE_H

#include <vector>
#include <array>
#include <cstddef>
#include <cmath>
#include <iostream>

class Spline {
public:
    // Constructor with optional tension parameter
    Spline(double tension = 0.5);

    void setTension(double tension);

    // Main interpolation function for 3D points
    std::vector<std::array<double, 3>> interpolate(
        const std::vector<std::array<double, 3>>& points, 
        int base_points_per_segment = 10
    );

private:
    double tension_;

    // Helper functions
    std::vector<double> solveTridiagonal(
        const std::vector<double>& a,
        const std::vector<double>& b,
        const std::vector<double>& c,
        const std::vector<double>& d
    );

    std::vector<double> computeSecondDerivatives(
        const std::vector<double>& x,
        const std::vector<double>& y
    );

    double interpolatePoint(
        const std::vector<double>& x,
        const std::vector<double>& y,
        const std::vector<double>& y2,
        double xi,
        size_t i
    );

    bool isRedundantPoint(
        const std::array<double, 3>& p1,
        const std::array<double, 3>& p2,
        double threshold = 0.3
    );

    bool isCurvatureAcceptable(
        const std::array<double, 3>& p1,
        const std::array<double, 3>& p2,
        const std::array<double, 3>& p3,
        double max_angle = M_PI/6
    );

    bool isPathValid(
        const std::vector<std::array<double, 3>>& original_path,
        const std::vector<std::array<double, 3>>& smoothed_path,
        double max_deviation = 3.0
    );

    // New helper functions for 3D
    static double distance3D(const std::array<double, 3>& p1, 
                           const std::array<double, 3>& p2);
    
    static std::array<double, 3> lerp3D(
        const std::array<double, 3>& p1,
        const std::array<double, 3>& p2,
        double t
    );
};

#endif // SPLINE_H

// spline.cpp 
#include "spline.h"
#include <stdexcept>
#include <algorithm>

Spline::Spline(double tension) {
    setTension(tension);
}

void Spline::setTension(double tension) {
    if (tension < 0.0 || tension > 1.0) {
        throw std::invalid_argument("Tension must be between 0 and 1");
    }
    tension_ = tension;
}

double Spline::distance3D(const std::array<double, 3>& p1, 
                         const std::array<double, 3>& p2) {
    double dx = p2[0] - p1[0];
    double dy = p2[1] - p1[1];
    double dz = p2[2] - p1[2];
    return std::sqrt(dx*dx + dy*dy + dz*dz);
}

std::array<double, 3> Spline::lerp3D(
    const std::array<double, 3>& p1,
    const std::array<double, 3>& p2,
    double t) {
    return {
        p1[0] + (p2[0] - p1[0]) * t,
        p1[1] + (p2[1] - p1[1]) * t,
        p1[2] + (p2[2] - p1[2]) * t
    };
}

std::vector<std::array<double, 3>> Spline::interpolate(
    const std::vector<std::array<double, 3>>& points,
    int base_points_per_segment
) {
    if (points.size() < 2) {
        return points;
    }

    try {
        // Calculate path parameterization
        std::vector<double> t(points.size());
        std::vector<double> x, y, z;
        x.reserve(points.size());
        y.reserve(points.size());
        z.reserve(points.size());

        // Initialize first point
        t[0] = 0.0;
        x.push_back(points[0][0]);
        y.push_back(points[0][1]);
        z.push_back(points[0][2]);

        double total_length = 0.0;
        for (size_t i = 1; i < points.size(); ++i) {
            double segment_length = distance3D(points[i-1], points[i]);
            
            if (segment_length < std::numeric_limits<double>::epsilon()) {
                continue;
            }
            
            total_length += segment_length;
            t[i] = total_length;
            x.push_back(points[i][0]);
            y.push_back(points[i][1]);
            z.push_back(points[i][2]);
        }

        if (total_length <= std::numeric_limits<double>::epsilon()) {
            return points;
        }

        // Normalize parameter to [0,1]
        for (auto& ti : t) {
            ti /= total_length;
        }

        // Compute second derivatives for each dimension
        std::vector<double> y2x = computeSecondDerivatives(t, x);
        std::vector<double> y2y = computeSecondDerivatives(t, y);
        std::vector<double> y2z = computeSecondDerivatives(t, z);

        // Generate interpolated points
        std::vector<std::array<double, 3>> interpolated_points;
        interpolated_points.reserve(points.size() * base_points_per_segment);
        interpolated_points.push_back(points[0]);

        for (size_t i = 0; i < points.size() - 1; ++i) {
            double segment_length = distance3D(points[i], points[i+1]);
            int num_points = std::max(5, 
                static_cast<int>(base_points_per_segment * segment_length / (total_length / points.size()))
            );

            for (int j = 1; j <= num_points; ++j) {
                double ti = t[i] + (t[i+1] - t[i]) * j / num_points;
                
                try {
                    double xi = interpolatePoint(t, x, y2x, ti, i);
                    double yi = interpolatePoint(t, y, y2y, ti, i);
                    double zi = interpolatePoint(t, z, y2z, ti, i);
                    
                    if (std::isfinite(xi) && std::isfinite(yi) && std::isfinite(zi)) {
                        std::array<double, 3> new_point = {xi, yi, zi};
                        
                        if (!isRedundantPoint(interpolated_points.back(), new_point)) {
                            if (interpolated_points.size() < 2 || 
                                isCurvatureAcceptable(
                                    interpolated_points[interpolated_points.size()-2],
                                    interpolated_points.back(),
                                    new_point
                                )) {
                                interpolated_points.push_back(new_point);
                            }
                        }
                    }
                } catch (const std::exception& e) {
                    continue;
                }
            }
        }

        if (!isPathValid(points, interpolated_points)) {
            if (tension_ > 0.5) {
                tension_ *= 0.9;
                return interpolate(points, base_points_per_segment);
            }
            return points;
        }

        return interpolated_points;

    } catch (const std::exception& e) {
        std::cerr << "Error in spline interpolation: " << e.what() << std::endl;
        return points;
    }
}

std::vector<double> Spline::solveTridiagonal(
    const std::vector<double>& a,
    const std::vector<double>& b,
    const std::vector<double>& c,
    const std::vector<double>& d
) {
    if (b.size() != d.size() || (b.size() != a.size() + 1) || (b.size() != c.size() + 1)) {
        throw std::invalid_argument("Invalid matrix dimensions for tridiagonal solver");
    }

    size_t n = b.size();
    std::vector<double> c_prime(n), d_prime(n), x(n);

    // Handle potential division by zero
    if (std::abs(b[0]) < std::numeric_limits<double>::epsilon()) {
        throw std::runtime_error("Zero diagonal element in tridiagonal solver");
    }

    // Forward sweep
    c_prime[0] = c[0] / b[0];
    d_prime[0] = d[0] / b[0];

    for (size_t i = 1; i < n; ++i) {
        double denominator = b[i] - a[i] * c_prime[i - 1];
        if (std::abs(denominator) < std::numeric_limits<double>::epsilon()) {
            throw std::runtime_error("Zero denominator in tridiagonal solver");
        }
        double m = 1.0 / denominator;
        c_prime[i] = i < n - 1 ? c[i] * m : 0;
        d_prime[i] = (d[i] - a[i] * d_prime[i - 1]) * m;
    }

    // Back substitution
    x[n - 1] = d_prime[n - 1];
    for (int i = n - 2; i >= 0; --i) {
        x[i] = d_prime[i] - c_prime[i] * x[i + 1];
    }

    return x;
}

double Spline::interpolatePoint(
    const std::vector<double>& x,
    const std::vector<double>& y,
    const std::vector<double>& y2,
    double xi,
    size_t i
) {
    if (i >= x.size() - 1) {
        throw std::out_of_range("Invalid index for interpolation");
    }

    double h = x[i + 1] - x[i];
    if (std::abs(h) < std::numeric_limits<double>::epsilon()) {
        throw std::runtime_error("Zero interval in interpolation");
    }

    double a = (x[i + 1] - xi) / h;
    double b = (xi - x[i]) / h;
    
    return a * y[i] + b * y[i + 1] + 
           ((a * a * a - a) * y2[i] + (b * b * b - b) * y2[i + 1]) * (h * h) / 6.0;
}

bool Spline::isRedundantPoint(
    const std::array<double, 3>& p1,
    const std::array<double, 3>& p2,
    double threshold
) {
    return distance3D(p1, p2) < threshold;
}

bool Spline::isCurvatureAcceptable(
    const std::array<double, 3>& p1,
    const std::array<double, 3>& p2,
    const std::array<double, 3>& p3,
    double max_angle
) {
    std::array<double, 3> v1 = {
        p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]
    };
    
    std::array<double, 3> v2 = {
        p3[0] - p2[0], p3[1] - p2[1], p3[2] - p2[2]
    };
    
    double mag1 = std::sqrt(v1[0]*v1[0] + v1[1]*v1[1] + v1[2]*v1[2]);
    double mag2 = std::sqrt(v2[0]*v2[0] + v2[1]*v2[1] + v2[2]*v2[2]);
    
    if (mag1 < std::numeric_limits<double>::epsilon() || 
        mag2 < std::numeric_limits<double>::epsilon()) {
        return true;
    }
    
    double dot = v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
    double cos_angle = std::min(std::max(dot / (mag1 * mag2), -1.0), 1.0);
    double angle = std::acos(cos_angle);
    
    return angle <= max_angle;
}

bool Spline::isPathValid(
    const std::vector<std::array<double, 3>>& original_path,
    const std::vector<std::array<double, 3>>& smoothed_path,
    double max_deviation
) {
    if (smoothed_path.empty()) return false;
    if (original_path.size() < 2) return true;

    for (const auto& smooth_point : smoothed_path) {
        double min_dist = std::numeric_limits<double>::max();
        
        for (size_t i = 0; i < original_path.size() - 1; ++i) {
            const auto& p1 = original_path[i];
            const auto& p2 = original_path[i + 1];
            
            std::array<double, 3> v1 = {
                p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]
            };
            std::array<double, 3> v2 = {
                smooth_point[0] - p1[0],
                smooth_point[1] - p1[1],
                smooth_point[2] - p1[2]
            };
            
            double len_sq = v1[0]*v1[0] + v1[1]*v1[1] + v1[2]*v1[2];
            
            if (len_sq < std::numeric_limits<double>::epsilon()) {
                double dist = distance3D(smooth_point, p1);
                min_dist = std::min(min_dist, dist);
                continue;
            }
            
            double t = (v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2]) / len_sq;
            t = std::min(std::max(t, 0.0), 1.0);
            
            std::array<double, 3> projection = {
                p1[0] + t * v1[0],
                p1[1] + t * v1[1],
                p1[2] + t * v1[2]
            };
            
            double dist = distance3D(smooth_point, projection);
            min_dist = std::min(min_dist, dist);
        }
        
        if (min_dist > max_deviation) {
            return false;
        }
    }
    return true;
}

std::vector<double> Spline::computeSecondDerivatives(
    const std::vector<double>& x,
    const std::vector<double>& y
) {
    size_t n = x.size();
    if (n < 2) {
        throw std::invalid_argument("Need at least two points for spline interpolation");
    }

    // Initialize vectors for the tridiagonal system
    std::vector<double> a(n-1), b(n), c(n-1), d(n);

    // First point
    b[0] = 2.0 * (x[1] - x[0]);
    c[0] = x[1] - x[0];
    d[0] = 6.0 * ((y[1] - y[0]) / (x[1] - x[0]));

    // Internal points
    for (size_t i = 1; i < n - 1; ++i) {
        double hi = x[i + 1] - x[i];
        double hi_1 = x[i] - x[i - 1];
        
        a[i-1] = hi_1;
        b[i] = 2.0 * (hi_1 + hi) * tension_;
        c[i] = hi;
        d[i] = 6.0 * ((y[i + 1] - y[i]) / hi - (y[i] - y[i - 1]) / hi_1);
    }

    // Last point
    a[n-2] = x[n-1] - x[n-2];
    b[n-1] = 2.0 * (x[n-1] - x[n-2]);
    d[n-1] = 6.0 * (-(y[n-1] - y[n-2]) / (x[n-1] - x[n-2]));

    return solveTridiagonal(a, b, c, d);
}