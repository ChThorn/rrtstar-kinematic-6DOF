// main.cpp 
#include "rrtstar.h"
#include <iostream>

int main() {
    // Define start and goal configurations in joint space
    std::array<double, 6> start_config = {0, 0, 0, 0, 0, 0};  // Home position
    std::array<double, 6> goal_config = {M_PI / 32, M_PI / 48, -M_PI / 48, 0, M_PI / 48, 0};
    try {
        RRTStar rrtstar(
            start_config,
            goal_config,
            400,    // Larger workspace width
            400,    // Larger workspace height
            400,    // Larger workspace depth
            0.05,   // Step size
            0.25,   // Neighbor radius
            0.1,    // Safety margin
            10000,  // Max iterations
            -100,      // Center workspace (x)
            -100,      // Center workspace (y)
            -100       // Center workspace (z)
        );

        // Find path
        std::cout << "Planning path..." << std::endl;
        auto path = rrtstar.findPath();
        if (path.empty()) {
            std::cout << "No path found!" << std::endl;
            return 1;
        }
        std::cout << "Path found with " << path.size() << " nodes!" << std::endl;

        // Print path
        std::cout << "\nPath (joint configurations):" << std::endl;
        for (const auto* node : path) {
            std::cout << "Joint values: ";
            for (size_t i = 0; i < 6; ++i) {
                std::cout << node->q[i] << " ";
            }
            auto pos = node->end_effector_position();
            std::cout << "| EE position: " << pos[0] << " " << pos[1] << " " << pos[2] << std::endl;
        }

        // Visualize path
        rrtstar.visualizePath(path);
        return 0;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
}

// rrtstar.cpp
#include "rrtstar.h"
#include <cmath>
#include <algorithm>
#include "matplotlibcpp.h"

namespace plt = matplotlibcpp;

std::array<DHParameters, 6> RobotKinematics::dh_params = {
    DHParameters(0,      M_PI / 2,  50,   0),  // Base to shoulder
    DHParameters(40,     0,         0,    0),  // Shoulder to elbow
    DHParameters(40,     0,         0,    0),  // Elbow to wrist
    DHParameters(0,      M_PI / 2,  20,   0),  // Wrist 1
    DHParameters(0,     -M_PI / 2,  0,    0),  // Wrist 2
    DHParameters(0,      0,        15,    0)   // End effector
};

// Define 3D obstacles with AABB (Axis-Aligned Bounding Box)
std::vector<Obstacle> RRTStar::obstacles = {
    Obstacle({45, 45, 45}, {55, 55, 55}),  // First cubic obstacle
    Obstacle({65, 65, 65}, {75, 75, 75})   // Second cubic obstacle
};

RRTStar::RRTStar(const std::array<double, 6>& start_q, const std::array<double, 6>& goal_q,
                 double map_width, double map_height, double map_depth,
                 double step_size, double neighbor_radius,
                 double safety_margin, int max_iter,
                 double min_x, double min_y, double min_z)
    : map_width(map_width), map_height(map_height), map_depth(map_depth),
      map_min_x(min_x), map_min_y(min_y), map_min_z(min_z),
      step_size(step_size), neighbor_radius(neighbor_radius),
      safety_margin(safety_margin), max_iter(max_iter),
      gen(std::random_device{}()),
      dis_x(min_x, min_x + map_width), 
      dis_y(min_y, min_y + map_height), 
      dis_z(min_z, min_z + map_depth),
      node_adapter(nodes) {
    
    std::cout << "Workspace bounds:\n"
              << "X: [" << map_min_x << ", " << map_min_x + map_width << "]\n"
              << "Y: [" << map_min_y << ", " << map_min_y + map_height << "]\n"
              << "Z: [" << map_min_z << ", " << map_min_z + map_depth << "]\n";
              
    if (!isStateValid(start_q) || !isStateValid(goal_q)) {
        throw std::invalid_argument("Start or goal configuration is invalid!");
    }
    start_node = std::make_unique<Node>(start_q);
    goal_node = std::make_unique<Node>(goal_q);
    nodes.push_back(start_node.get());

    // Fixed the template syntax by putting it all on one line
    kdtree = std::make_unique<nanoflann::KDTreeSingleIndexAdaptor<nanoflann::L2_Simple_Adaptor<double, NodeAdapter>, NodeAdapter, 6, unsigned int>>(
        6, node_adapter, nanoflann::KDTreeSingleIndexAdaptorParams());
    kdtree->buildIndex();
}

RRTStar::~RRTStar() = default;

bool RRTStar::lineAABBIntersection(const std::array<double, 3>& start,
                                   const std::array<double, 3>& end,
                                   const std::array<double, 3>& box_min,
                                   const std::array<double, 3>& box_max) {
    std::array<double, 3> dir = {
        (end[0] - start[0]) * 0.5,
        (end[1] - start[1]) * 0.5,
        (end[2] - start[2]) * 0.5
    };
    
    std::array<double, 3> mid = {
        (start[0] + end[0]) * 0.5,
        (start[1] + end[1]) * 0.5,
        (start[2] + end[2]) * 0.5
    };
    
    std::array<double, 3> extent = {
        std::abs(dir[0]), std::abs(dir[1]), std::abs(dir[2])
    };
    
    // Normalize direction vector
    double length = std::sqrt(dir[0]*dir[0] + dir[1]*dir[1] + dir[2]*dir[2]);
    if (length > 1e-9) {
        for (int i = 0; i < 3; i++) dir[i] /= length;
    }

    std::array<double, 3> box_center = {
        (box_min[0] + box_max[0]) * 0.5,
        (box_min[1] + box_max[1]) * 0.5,
        (box_min[2] + box_max[2]) * 0.5
    };
    
    std::array<double, 3> box_half = {
        (box_max[0] - box_min[0]) * 0.5,
        (box_max[1] - box_min[1]) * 0.5,
        (box_max[2] - box_min[2]) * 0.5
    };

    std::array<double, 3> t = {
        mid[0] - box_center[0],
        mid[1] - box_center[1],
        mid[2] - box_center[2]
    };

    // Test axes
    for (int i = 0; i < 3; i++) {
        if (std::abs(t[i]) > box_half[i] + extent[i]) return false;
    }

    // Test cross products
    for (int i = 0; i < 3; i++) {
        int a = (i+1)%3;
        int b = (i+2)%3;
        double radius = box_half[a] * std::abs(dir[b]) + box_half[b] * std::abs(dir[a]);
        double distance = std::abs(t[a] * dir[b] - t[b] * dir[a]);
        if (distance > radius) return false;
    }

    return true;
}

std::vector<Node*> RRTStar::findPath() {
    for (int i = 0; i < max_iter; ++i) {
        auto random_node = getRandomNode();
        Node* nearest_node = nearest(random_node.get());
        auto new_node = steer(nearest_node, random_node.get());
        if (isCollisionFree(nearest_node, new_node.get())) {
            std::vector<Node*> neighbors = radiusSearch(new_node.get(), neighbor_radius);
            Node* min_cost_node = nearest_node;
            double min_cost = nearest_node->cost + distance(nearest_node, new_node.get());
            for (auto& neighbor : neighbors) {
                if (isCollisionFree(neighbor, new_node.get())) {
                    double tentative_cost = neighbor->cost + distance(neighbor, new_node.get());
                    if (tentative_cost < min_cost) {
                        min_cost = tentative_cost;
                        min_cost_node = neighbor;
                    }
                }
            }
            new_node->parent = min_cost_node;
            new_node->cost = min_cost;
            nodes.push_back(new_node.get());
            node_storage.push_back(std::move(new_node));
            // kdtree->buildIndex();
            // Rebuild KD-tree periodically
            if (nodes.size() % 100 == 0) {
                kdtree->buildIndex();
            }
            rewire(neighbors, nodes.back());
            if (distance(nodes.back(), goal_node.get()) <= step_size &&
                isCollisionFree(nodes.back(), goal_node.get())) {
                goal_node->parent = nodes.back();
                goal_node->cost = nodes.back()->cost + distance(nodes.back(), goal_node.get());
                break;
            }
        }
    }
    std::vector<Node*> path;
    if (goal_node->parent != nullptr) {
        getFinalPath(goal_node.get(), path);
    }
    return path;
}

std::unique_ptr<Node> RRTStar::getRandomNode() {
    std::array<double, 6> q;
    int max_attempts = 100;
    int attempts = 0;
    do {
        for (size_t i = 0; i < 6; ++i) {
            double range = joint_limits_max[i] - joint_limits_min[i];
            double center = (joint_limits_max[i] + joint_limits_min[i]) / 2.0;
            double u = std::uniform_real_distribution<>(0.0, 1.0)(gen);
            double v = std::uniform_real_distribution<>(0.0, 1.0)(gen);
            q[i] = center + (u < 0.5 ? 1 : -1) * range * (1.0 - std::sqrt(v)) / 2.0;
        }
        attempts++;
        if (attempts >= max_attempts) {
            std::cout << "Maximum attempts reached in getRandomNode" << std::endl;
            // Try midpoint of joint limits
            for (size_t i = 0; i < 6; i++) {
                q[i] = (joint_limits_max[i] + joint_limits_min[i]) / 2.0;
            }
            break;
        }
        auto pos = RobotKinematics::computeFK(q);

        // Debugging output
        std::cout << "Joint angles: ";
        for (double angle : q) std::cout << angle << " ";
        std::cout << "\nEnd-effector position: " << pos[0] << ", " << pos[1] << ", " << pos[2] << std::endl;

        if (attempts % 10 == 0) {
            std::cout << "Attempt " << attempts << " - Position: "
                      << pos[0] << ", " << pos[1] << ", " << pos[2] << std::endl;
        }
    } while (!isStateValid(q));
    return std::make_unique<Node>(q);
}

std::unique_ptr<Node> RRTStar::steer(Node* nearest_node, Node* random_node) {
    std::array<double, 6> new_q;
    for (size_t i = 0; i < 6; ++i) {
        double dq = random_node->q[i] - nearest_node->q[i];
        new_q[i] = nearest_node->q[i] + dq * step_size / distance(nearest_node, random_node);
        new_q[i] = std::max(joint_limits_min[i], std::min(new_q[i], joint_limits_max[i]));
    }

    // Debugging output
    auto pos = RobotKinematics::computeFK(new_q);
    std::cout << "Steered joint angles: ";
    for (double angle : new_q) std::cout << angle << " ";
    std::cout << "\nSteered end-effector position: " << pos[0] << ", " << pos[1] << ", " << pos[2] << std::endl;

    return std::make_unique<Node>(new_q);
}

bool RRTStar::isCollisionFree(Node* node1, Node* node2) {
    const int steps = 10;  // Number of interpolation steps
    for (int i = 0; i <= steps; i++) {
        double t = static_cast<double>(i) / steps;
        std::array<double, 6> q_interp;
        // Interpolate joint values
        for (size_t j = 0; j < 6; j++) {
            double diff = node2->q[j] - node1->q[j];
            // Handle angular wrap-around
            if (diff > M_PI) diff -= 2 * M_PI;
            if (diff < -M_PI) diff += 2 * M_PI;
            q_interp[j] = node1->q[j] + t * diff;
        }

        // Debugging output
        auto pos = RobotKinematics::computeFK(q_interp);
        std::cout << "Interpolated joint angles: ";
        for (double angle : q_interp) std::cout << angle << " ";
        std::cout << "\nInterpolated end-effector position: " << pos[0] << ", " << pos[1] << ", " << pos[2] << std::endl;

        // Check joint limits
        if (!RobotKinematics::isJointLimitValid(q_interp)) {
            return false;
        }
        // Check end-effector position against obstacles
        std::array<double, 3> point = {pos[0], pos[1], pos[2]};
        for (const auto& obstacle : obstacles) {
            bool inside = true;
            for (int j = 0; j < 3; ++j) {
                if (point[j] < obstacle.min_point[j] - safety_margin || 
                    point[j] > obstacle.max_point[j] + safety_margin) {
                    inside = false;
                    break;
                }
            }
            if (inside) return false;
        }
    }
    return true;
}

void RRTStar::rewire(const std::vector<Node*>& neighbors, Node* new_node) {
    for(auto* neighbor : neighbors) {
        if (isCollisionFree(neighbor, new_node)) {
            double tentative_cost = new_node->cost + distance(new_node, neighbor);
            if (tentative_cost < neighbor->cost) {
                neighbor->parent = new_node;
                neighbor->cost = tentative_cost;
            }
        }
    }
}

double RRTStar::distance(Node* node1, Node* node2) {
    double joint_dist = 0.0;
    for(size_t i = 0; i < 6; i++) {
        double diff = node2->q[i] - node1->q[i];
        // Handle angular wrap-around
        if(diff > M_PI) diff -= 2*M_PI;
        if(diff < -M_PI) diff += 2*M_PI;
        joint_dist += diff * diff;
    }
    
    // Combine joint space and task space distances
    auto pos1 = node1->end_effector_position();
    auto pos2 = node2->end_effector_position();
    double task_dist = std::pow(pos2[0] - pos1[0], 2) + 
                      std::pow(pos2[1] - pos1[1], 2) + 
                      std::pow(pos2[2] - pos1[2], 2);
    
    return std::sqrt(joint_dist) + 0.1 * std::sqrt(task_dist);
}

Node* RRTStar::nearest(Node* target) {
    double query_pt[6];
    for (size_t i = 0; i < 6; ++i) {
        query_pt[i] = target->q[i];
    }
    unsigned int index;
    double min_dist_sq;
    kdtree->knnSearch(query_pt, 1, &index, &min_dist_sq);
    return nodes[index];
}

std::vector<Node*> RRTStar::radiusSearch(Node* target, double radius) {
    double query_pt[6];
    for (size_t i = 0; i < 6; ++i) {
        query_pt[i] = target->q[i];
    }
    
    // Use the correct result type that nanoflann expects
    std::vector<nanoflann::ResultItem<unsigned int, double>> ret_matches;
    
    // Perform radius search
    kdtree->radiusSearch(
        query_pt,
        radius * radius,
        ret_matches,
        nanoflann::SearchParameters()
    );
    
    // Convert results to Node pointers
    std::vector<Node*> result;
    result.reserve(ret_matches.size());
    for (const auto& match : ret_matches) {
        result.push_back(nodes[match.first]);
    }
    
    return result;
}

void RRTStar::getFinalPath(Node* goal_node, std::vector<Node*>& path) {
    Node* current = goal_node;
    while (current != nullptr) {
        path.push_back(current);
        current = current->parent;
    }
    std::reverse(path.begin(), path.end());
}

void RRTStar::optimizePath(std::vector<Node*>& path) {
    if (path.size() < 3) return;

    bool improved;
    do {
        improved = false;
        // Forward pass
        size_t i = 0;
        while (i < path.size() - 2) {
            if (isCollisionFree(path[i], path[i + 2])) {
                path.erase(path.begin() + i + 1);
                improved = true;
            } else {
                i++;
            }
        }

        // Backward pass to catch missed opportunities
        i = path.size() - 1;
        while (i >= 2) {
            if (isCollisionFree(path[i - 2], path[i])) {
                path.erase(path.begin() + i - 1);
                improved = true;
            }
            i--;
        }
    } while (improved); // Repeat until no more improvements
}

bool RRTStar::isStateValid(const std::array<double, 6>& q) {
    if (!RobotKinematics::isJointLimitValid(q)) {
        std::cout << "Joint limits violated!" << std::endl;
        return false;
    }
    auto pos = RobotKinematics::computeFK(q);
    bool valid = pos[0] >= map_min_x && pos[0] <= (map_min_x + map_width) &&
                 pos[1] >= map_min_y && pos[1] <= (map_min_y + map_height) &&
                 pos[2] >= map_min_z && pos[2] <= (map_min_z + map_depth);
    if (!valid) {
        std::cout << "Position (" << pos[0] << ", " << pos[1] << ", " << pos[2] 
                  << ") is outside workspace bounds [" << map_min_x << "," << (map_min_x + map_width) 
                  << "] x [" << map_min_y << "," << (map_min_y + map_height)
                  << "] x [" << map_min_z << "," << (map_min_z + map_depth) << "]" << std::endl;
    }
    return valid;
}

bool RRTStar::isObstacle(double x, double y, double z) {
    std::array<double, 3> point = {x, y, z};
    
    for (const auto& obstacle : obstacles) {
        bool inside = true;
        for (int i = 0; i < 3; ++i) {
            if (point[i] < obstacle.min_point[i] - safety_margin || 
                point[i] > obstacle.max_point[i] + safety_margin) {
                inside = false;
                break;
            }
        }
        if (inside) return true;
    }
    return false;
}

void RRTStar::visualizePath(const std::vector<Node*>& path) {
    // Set backend explicitly for headless environments
    plt::backend("Agg");

    // Create a new figure
    plt::figure_size(1200, 800);

    // Plot tree nodes and edges
    std::vector<double> x_coords, y_coords, z_coords;
    for (const auto& node : nodes) {
        x_coords.push_back(node->x);
        y_coords.push_back(node->y);
        z_coords.push_back(node->z);
    }

    // Plot tree edges
    for (const auto& node : nodes) {
        if (node->parent != nullptr) {
            std::vector<double> edge_x = {node->x, node->parent->x};
            std::vector<double> edge_y = {node->y, node->parent->y};
            std::vector<double> edge_z = {node->z, node->parent->z};
            plt::plot3(edge_x, edge_y, edge_z, {{"color", "lightblue"}, {"linestyle", "-"}, {"linewidth", "0.5"}});
        }
    }

    // Plot all nodes
    plt::plot3(x_coords, y_coords, z_coords, {{"color", "blue"}, {"marker", "."}, 
        {"linestyle", "none"}, {"markersize", "5"}, {"label", "Tree Nodes"}});

    // Plot original path
    if (!path.empty()) {
        std::vector<double> path_x, path_y, path_z;
        for (const auto& node : path) {
            path_x.push_back(node->x);
            path_y.push_back(node->y);
            path_z.push_back(node->z);
        }
        plt::plot3(path_x, path_y, path_z, {{"color", "orange"}, {"linestyle", "--"}, 
            {"linewidth", "2.0"}, {"label", "Original Path"}});
    }

    // Plot start and goal
    std::vector<double> start_xyz = {start_node->x, start_node->y, start_node->z};
    plt::plot3(std::vector<double>{start_xyz[0]}, 
               std::vector<double>{start_xyz[1]}, 
               std::vector<double>{start_xyz[2]}, 
               {{"color", "green"}, {"marker", "*"}, {"markersize", "15"}, {"label", "Start"}});

    std::vector<double> goal_xyz = {goal_node->x, goal_node->y, goal_node->z};
    plt::plot3(std::vector<double>{goal_xyz[0]}, 
               std::vector<double>{goal_xyz[1]}, 
               std::vector<double>{goal_xyz[2]}, 
               {{"color", "red"}, {"marker", "*"}, {"markersize", "15"}, {"label", "Goal"}});

    // Plot obstacles
    for (const auto& obstacle : obstacles) {
        // Plot each face of the box
        std::array<double, 8> x_corners = {
            obstacle.min_point[0], obstacle.max_point[0],
            obstacle.max_point[0], obstacle.min_point[0],
            obstacle.min_point[0], obstacle.max_point[0],
            obstacle.max_point[0], obstacle.min_point[0]
        };
        std::array<double, 8> y_corners = {
            obstacle.min_point[1], obstacle.min_point[1],
            obstacle.max_point[1], obstacle.max_point[1],
            obstacle.min_point[1], obstacle.min_point[1],
            obstacle.max_point[1], obstacle.max_point[1]
        };
        std::array<double, 8> z_corners = {
            obstacle.min_point[2], obstacle.min_point[2],
            obstacle.min_point[2], obstacle.min_point[2],
            obstacle.max_point[2], obstacle.max_point[2],
            obstacle.max_point[2], obstacle.max_point[2]
        };
        // Plot box edges
        for (int i = 0; i < 4; ++i) {
            int j = (i + 1) % 4;
            std::vector<double> edge_x = {x_corners[i], x_corners[j]};
            std::vector<double> edge_y = {y_corners[i], y_corners[j]};
            std::vector<double> edge_z = {z_corners[i], z_corners[j]};
            plt::plot3(edge_x, edge_y, edge_z, {{"color", "black"}, {"linestyle", "-"}, {"alpha", "0.5"}});
            // Vertical edges
            std::vector<double> v_edge_x = {x_corners[i], x_corners[i+4]};
            std::vector<double> v_edge_y = {y_corners[i], y_corners[i+4]};
            std::vector<double> v_edge_z = {z_corners[i], z_corners[i+4]};
            plt::plot3(v_edge_x, v_edge_y, v_edge_z, {{"color", "black"}, {"linestyle", "-"}, {"alpha", "0.5"}});
        }
    }

    // Add labels, title, grid, and legend
    plt::xlabel("X");
    plt::ylabel("Y");
    plt::set_zlabel("Z");
    plt::title("RRT* Path Planning in 3D");
    plt::grid(true);
    plt::legend();

    // Save the plot to a file
    plt::save("/home/thornch/Documents/Cpp/PathPlanning/rrtstar_test1/path_plot.png");
    std::cout << "Plot saved to path_plot.png" << std::endl;

    // Close the figure to free resources
    // plt.close();
    plt::clf();
}

void exportData(const std::vector<Node*>& path, const std::vector<Obstacle>& obstacles, const std::string& filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open file for exporting data." << std::endl;
        return;
    }
    
    // Write original path
    file << "original_path\n";
    for (const auto& node : path) {
        file << node->x << "," << node->y << "," << node->z << "\n";
    }
    
    // Write smoothed path (if applicable)
    file << "smoothed_path\n";
    for (const auto& node : path) {
        file << node->x << "," << node->y << "," << node->z << "\n";
    }
    
    // Write obstacles
    file << "obstacles\n";
    for (const auto& obstacle : obstacles) {
        file << obstacle.min_point[0] << "," << obstacle.min_point[1] << "," << obstacle.min_point[2] << ","
             << obstacle.max_point[0] << "," << obstacle.max_point[1] << "," << obstacle.max_point[2] << "\n";
    }
    file.close();
}

// rrtstar.h
#ifndef RRTSTAR_H
#define RRTSTAR_H

#include <vector>
#include <array>
#include <memory>
#include <random>
#include <cmath>
#include "nanoflann.hpp"
#include <fstream>
#include <map>
#include <string>

struct DHParameters {
    double a;      // link length
    double alpha;  // link twist
    double d;      // link offset
    double theta;  // joint angle
    
    DHParameters(double a_, double alpha_, double d_, double theta_)
        : a(a_), alpha(alpha_), d(d_), theta(theta_) {}
};

class RobotKinematics {
public:
    static std::array<DHParameters, 6> dh_params;
    
    static std::array<double, 16> transformDH(const DHParameters& dh) {
        double ct = std::cos(dh.theta);
        double st = std::sin(dh.theta);
        double ca = std::cos(dh.alpha);
        double sa = std::sin(dh.alpha);
        
        return {
            ct, -st * ca,  st * sa, dh.a * ct,
            st,  ct * ca, -ct * sa, dh.a * st,
            0,   sa,       ca,      dh.d,
            0,   0,        0,       1
        };
    }
    
    static std::array<double, 16> multiplyTransforms(
        const std::array<double, 16>& A, 
        const std::array<double, 16>& B) {
        std::array<double, 16> C;
        for(int i = 0; i < 4; i++) {
            for(int j = 0; j < 4; j++) {
                C[i*4 + j] = 0;
                for(int k = 0; k < 4; k++) {
                    C[i*4 + j] += A[i*4 + k] * B[k*4 + j];
                }
            }
        }
        return C;
    }
    
    static std::array<double, 3> computeFK(const std::array<double, 6>& joints) {
        auto T = transformDH(DHParameters(
            dh_params[0].a, 
            dh_params[0].alpha, 
            dh_params[0].d, 
            joints[0]
        ));
        for (int i = 1; i < 6; i++) {
            auto Ti = transformDH(DHParameters(
                dh_params[i].a, 
                dh_params[i].alpha, 
                dh_params[i].d, 
                joints[i]
            ));
            T = multiplyTransforms(T, Ti);
        }
        return {T[3], T[7], T[11]};
    }
    
    static bool isJointLimitValid(const std::array<double, 6>& joints) {
        const std::array<double, 6> limits_min = {-M_PI, -M_PI/2, -M_PI, -M_PI, -M_PI/2, -M_PI};
        const std::array<double, 6> limits_max = {M_PI, M_PI/2, M_PI, M_PI, M_PI/2, M_PI};
        
        for(size_t i = 0; i < 6; i++) {
            if(joints[i] < limits_min[i] || joints[i] > limits_max[i]) {
                return false;
            }
        }
        return true;
    }
};

struct Node {
    std::array<double, 6> q;  // Joint angles
    double x, y, z;          // End-effector position
    Node* parent = nullptr;
    double cost = 0.0;

    Node(const std::array<double, 6>& q_) : q(q_) {
        auto pos = RobotKinematics::computeFK(q_);
        x = pos[0];
        y = pos[1];
        z = pos[2];
    }

    std::array<double, 3> end_effector_position() const {
        return RobotKinematics::computeFK(q);
    }
};

struct Obstacle {
    std::array<double, 3> min_point;
    std::array<double, 3> max_point;
    Obstacle(const std::array<double, 3>& min, const std::array<double, 3>& max)
        : min_point(min), max_point(max) {}
};

class RRTStar {
private:
    // Joint limits for each DOF
    std::array<double, 6> joint_limits_min = {-M_PI/4, -M_PI/6, -M_PI/6, -M_PI/4, -M_PI/6, -M_PI/4};
    std::array<double, 6> joint_limits_max = {M_PI/4,  M_PI/6,  M_PI/6,  M_PI/4,  M_PI/6,  M_PI/4};
    // Map parameters
    double map_width, map_height, map_depth;
    double map_min_x, map_min_y, map_min_z; // Add minimum bounds
    double step_size, neighbor_radius, safety_margin;
    int max_iter;

    // Random number generation
    std::mt19937 gen;
    std::uniform_real_distribution<> dis_x, dis_y, dis_z;

    // Nodes and storage
    std::vector<Node*> nodes;
    std::vector<std::unique_ptr<Node>> node_storage;

    // KD-tree for efficient nearest neighbor search
    struct NodeAdapter {
        std::vector<Node*>& nodes;
        NodeAdapter(std::vector<Node*>& nodes) : nodes(nodes) {}
        inline size_t kdtree_get_point_count() const { return nodes.size(); }
        inline double kdtree_get_pt(const size_t idx, const size_t dim) const {
            return nodes[idx]->q[dim];
        }
        template <typename BBOX>
        bool kdtree_get_bbox(BBOX&) const { return false; }
    };
    NodeAdapter node_adapter;
    std::unique_ptr<nanoflann::KDTreeSingleIndexAdaptor<
        nanoflann::L2_Simple_Adaptor<double, NodeAdapter>,
        NodeAdapter, 6>> kdtree;

    // Start and goal nodes
    std::unique_ptr<Node> start_node;
    std::unique_ptr<Node> goal_node;

    // Static obstacle list
    static std::vector<Obstacle> obstacles;

    // Helper functions
    std::unique_ptr<Node> getRandomNode();
    std::unique_ptr<Node> steer(Node* nearest_node, Node* random_node);
    bool isCollisionFree(Node* node1, Node* node2);
    void rewire(const std::vector<Node*>& neighbors, Node* new_node);
    bool isObstacle(double x, double y, double z);
    bool lineAABBIntersection(const std::array<double, 3>& start,
                              const std::array<double, 3>& end,
                              const std::array<double, 3>& box_min,
                              const std::array<double, 3>& box_max);

public:
    RRTStar(const std::array<double, 6>& start_q, const std::array<double, 6>& goal_q,
            double map_width, double map_height, double map_depth,
            double step_size, double neighbor_radius,
            double safety_margin, int max_iter,
            double min_x = -500, double min_y = -500, double min_z = 0); // Add defaults
    ~RRTStar();
    std::vector<Node*> findPath();
    void getFinalPath(Node* goal_node, std::vector<Node*>& path);
    void optimizePath(std::vector<Node*>& path);
    bool isStateValid(const std::array<double, 6>& q);
    void visualizePath(const std::vector<Node*>& path);
    Node* nearest(Node* target);
    std::vector<Node*> radiusSearch(Node* target, double radius);
    double distance(Node* node1, Node* node2);
    // void smoothPath(std::vector<Node*>& path);

    // Getter for obstacles
    static const std::vector<Obstacle>& getObstacles() {
        return obstacles;
    }
};

void exportData(const std::vector<Node*>& path, const std::vector<Obstacle>& obstacles, const std::string& filename);

#endif // RRTSTAR_H